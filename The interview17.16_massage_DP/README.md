#### [面试题 17.16. 按摩师](https://leetcode-cn.com/problems/the-masseuse-lcci/)

**题目：**一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。

注意：本题相对原题稍作改动

 

**示例 1：**

输入： [1,2,3,1]
       输出： 4
       解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。

**示例 2：**

输入： [2,7,9,3,1]
       输出： 12
       解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。

**示例 3：**

输入： [2,1,4,5,3,1,1,3]
       输出： 12
       解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。

**解题思路：**

这是一套动态规划的问题。这种类型的题还是很难的，基本上摸索不出来一套固定的解题思路，我是看了Leedcode上官方给出的解题思路后，自己又写了一遍完成的。

**dp**i[0]表示在考虑前i个预约，第i个预约不接的最长预约时间，**dpi[1]**表示考虑前i个预约，第i个预约接的最长预约时间。

我们要计算**dpi[0/1]**，如果**dpi[0]**，表示第i个预约不接，那么第i-1接或者不接都可以；如果**dpi[1]**，表示第i个预约接，那么第i-1个预约就不能再接了。

**dpi[0]** = max(**dpi-1[0]**, d**pi-1[1]**)

**dpi[1]** = **dpi-1[0]** + nums[i]

```c++
class Solution {
public:
	int massage(vector<int>& nums) {
		if (nums.size()== 0) return 0;
		int dp0 = 0, dp1 = nums[0];
		for (int i = 1; i < nums.size(); i++) {
			int tdp0 = max(dp0, dp1);
			int tdp1 = dp0 + nums[i];

			dp0 = tdp0;
			dp1 = tdp1;
		}
		return max(dp0, dp1);
	}
};
```

